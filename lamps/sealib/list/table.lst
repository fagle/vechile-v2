###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.3.8902/W32 for ARM        25/Oct/2015  14:11:37
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  D:\projects\VehicleV2\trunk\lamps\sealib\lamp\table.c
#    Command line =  
#        D:\projects\VehicleV2\trunk\lamps\sealib\lamp\table.c -D
#        ENABLE_GATEWAY -D NULL_BTL -D CORTEXM3_EM357 -lC
#        D:\projects\VehicleV2\trunk\lamps\sealib\list\ --diag_suppress Pa050
#        -o D:\projects\VehicleV2\trunk\lamps\sealib\obj\ --debug
#        --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        D:\projects\VehicleV2\trunk\lamps\sealib\..\inc\ -I
#        D:\projects\VehicleV2\trunk\lamps\sealib\..\inc\hal\ -I
#        D:\projects\VehicleV2\trunk\lamps\sealib\..\inc\hal\cortexm3\ -I
#        D:\projects\VehicleV2\trunk\lamps\sealib\..\inc\stack\ -I
#        D:\projects\VehicleV2\trunk\lamps\sealib\..\inc\util\ -I
#        D:\projects\VehicleV2\trunk\lamps\sealib\..\inc\car\ -Ohz
#        --use_c++_inline
#    List file    =  D:\projects\VehicleV2\trunk\lamps\sealib\list\table.lst
#    Object file  =  D:\projects\VehicleV2\trunk\lamps\sealib\obj\table.o
#
###############################################################################

D:\projects\VehicleV2\trunk\lamps\sealib\lamp\table.c
      1          #include "network.h"
      2          #include "flash.h"
      3          
      4          /////////////////////////////////////////////////////////////////////////////////////////////
      5          //

   \                                 In section .bss, align 4
      6          table_t   table_info;
   \                     table_info:
   \   00000000                      DS8 28
      7          
      8          /////////////////////////////////////////////////////////////////////////////////////////////
      9          // 分配给每个人的程序有不同的网络号，防止分配错误。
     10          // (19, 0x1010) 莫雪娟实验
     11          // (19, 0x0505) 实验室路灯组网实验
     12          // (21, 0x0a0a) 实验室网关实验主网络
     13          // (23, 0x0f0f) 实验室网关实验辅网络
     14          // (17, 0x7777) 郭太磊实验
     15          // (17, 0x7777) 第二次寄望湖州的网络号

   \                                 In section .text, align 4, keep-with-next
     16          const panid_t panid_info[] = { {11, 0x1212}, {12, 0x0f0f}, {13, 0x1010}, {14, 0x0808}, 
   \                     panid_info:
   \   00000000   0x0B 0x00          DC8 11, 0
   \   00000002   0x1212             DC16 4626
   \   00000004   0x0C 0x00          DC8 12, 0
   \   00000006   0x0F0F             DC16 3855
   \   00000008   0x0D 0x00          DC8 13, 0
   \   0000000A   0x1010             DC16 4112
   \   0000000C   0x0E 0x00          DC8 14, 0
   \   0000000E   0x0808             DC16 2056
   \   00000010   0x0F 0x00          DC8 15, 0
   \   00000012   0x5858             DC16 22616
   \   00000014   0x10 0x00          DC8 16, 0
   \   00000016   0x0A0A             DC16 2570
   \   00000018   0x17 0x00          DC8 23, 0
   \   0000001A   0x0101             DC16 257
   \   0000001C   0x12 0x00          DC8 18, 0
   \   0000001E   0x6868             DC16 26728
   \   00000020   0x13 0x00          DC8 19, 0
   \   00000022   0xA0A0             DC16 41120
   \   00000024   0x14 0x00          DC8 20, 0
   \   00000026   0x9090             DC16 37008
   \   00000028   0x15 0x00          DC8 21, 0
   \   0000002A   0x9898             DC16 39064
   \   0000002C   0x16 0x00          DC8 22, 0
   \   0000002E   0x0505             DC16 1285
   \   00000030   0x11 0x00          DC8 17, 0
   \   00000032   0x7070             DC16 28784
   \   00000034   0x18 0x00          DC8 24, 0
   \   00000036   0x5050             DC16 20560
   \   00000038   0x19 0x00          DC8 25, 0
   \   0000003A   0xF0F0             DC16 61680
   \   0000003C   0x1A 0x00          DC8 26, 0
   \   0000003E   0x0606             DC16 1542
   \   00000040   0x11 0x00          DC8 17, 0
   \   00000042   0x7676             DC16 30326
   \   00000044   0x13 0x00          DC8 19, 0
   \   00000046   0x6767             DC16 26471
   \   00000048   0x12 0x00          DC8 18, 0
   \   0000004A   0x5A5A             DC16 23130
   \   0000004C   0x17 0x00          DC8 23, 0
   \   0000004E   0xA5A5             DC16 42405
     17                                         {15, 0x5858}, {16, 0x0a0a}, {23, 0x0101}, {18, 0x6868}, 
     18                                         {19, 0xa0a0}, {20, 0x9090}, {21, 0x9898}, {22, 0x0505}, 
     19                                         {17, 0x7070}, {24, 0x5050}, {25, 0xf0f0}, {26, 0x0606},
     20                                         {17, 0x7676}, {19, 0x6767}, {18, 0x5a5a}, {23, 0xa5a5}, };
     21          
     22             
     23          /////////////////////////////////////////////////////////////////////////////////////////////
     24          //
     25          //* 函数名      : void sea_writedefaultconfig ( u8 app, u8 type, u8 index, u32 mask )
     26          //* 功能        : write default system information configuration
     27          //* 输入参数    : u8 app, u8 type, u8 index, u32 mask
     28          //* 输出参数    : 无
     29          //* 修改记录    : 无
     30          //* 备注        : 无
     31          //*------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
     32          void sea_writedefaultconfig ( u8 app, u8 type, u8 index, u32 mask )
     33          {
   \                     sea_writedefaultconfig: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4690             MOV      R8,R2
     34              u8  retry = 0x05; 
     35          
     36              Debug("\r\nwrite default system information to flash.");
     37              sea_memset(&sys_info, 0x00, sizeof(sys_info_t));
   \   0000000A   0x.... 0x....      LDR.W    R7,??DataTable19
   \   0000000E   0x4699             MOV      R9,R3
   \   00000010   0x2258             MOVS     R2,#+88
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0x4638             MOV      R0,R7
   \   00000016   0x.... 0x....      BL       sea_memset
     38              
     39              sys_info.channel.index   = index;
   \   0000001A   0xF107 0x0044      ADD      R0,R7,#+68
     40              sys_info.channel.mask    = mask;                                         // 0x0000ffff, 0x10 channels
     41              sys_info.channel.panid   = panid_info[sys_info.channel.index].panid;     // DEF_PANID;
   \   0000001E   0x.... 0x....      ADR.W    R1,panid_info
   \   00000022   0xF880 0x800A      STRB     R8,[R0, #+10]
   \   00000026   0xEB01 0x0288      ADD      R2,R1,R8, LSL #+2
   \   0000002A   0xF8C0 0x9000      STR      R9,[R0, #+0]
   \   0000002E   0x2605             MOVS     R6,#+5
   \   00000030   0x8852             LDRH     R2,[R2, #+2]
   \   00000032   0x8082             STRH     R2,[R0, #+4]
     42              sys_info.channel.channel = panid_info[sys_info.channel.index].channel;   // DEF_CHANNEL;
   \   00000034   0x4642             MOV      R2,R8
   \   00000036   0xF811 0x1022      LDRB     R1,[R1, R2, LSL #+2]
   \   0000003A   0x7241             STRB     R1,[R0, #+9]
     43              sys_info.channel.power   = DEF_POWER;
   \   0000003C   0x7206             STRB     R6,[R0, #+8]
     44              sys_info.channel.profile = DEF_PROFILE;
   \   0000003E   0xF24C 0x2166      MOVW     R1,#+49766
   \   00000042   0x80C1             STRH     R1,[R0, #+6]
     45              sea_memcpy(sys_info.key.link, DEF_LINKKEY, EMBER_ENCRYPTION_KEY_SIZE);
   \   00000044   0x2210             MOVS     R2,#+16
   \   00000046   0x.... 0x....      ADR.W    R1,?_0
   \   0000004A   0xF107 0x0012      ADD      R0,R7,#+18
   \   0000004E   0x.... 0x....      BL       sea_memcpy
     46              sea_memcpy(sys_info.key.network, DEF_NETWORKKEY, EMBER_ENCRYPTION_KEY_SIZE);
   \   00000052   0x2210             MOVS     R2,#+16
   \   00000054   0x.... 0x....      ADR.W    R1,?_1
   \   00000058   0xF107 0x0022      ADD      R0,R7,#+34
   \   0000005C   0x.... 0x....      BL       sea_memcpy
     47              sea_memcpy(sys_info.channel.expanid, DEF_EXPAN, EXTENDED_PAN_ID_SIZE);
   \   00000060   0x2208             MOVS     R2,#+8
   \   00000062   0x.... 0x....      ADR.W    R1,?_2
   \   00000066   0xF107 0x004F      ADD      R0,R7,#+79
   \   0000006A   0x.... 0x....      BL       sea_memcpy
     48              
     49              sys_info.mark         = SYSMARK;
     50              sys_info.size         = sizeof(sys_info_t);
     51              sys_info.dev.type     = type;
     52              sys_info.ctrl.maxdev  = EMBER_MAXDEVS;
   \   0000006E   0x21FA             MOVS     R1,#+250
   \   00000070   0x80B9             STRH     R1,[R7, #+4]
   \   00000072   0xF245 0x50AA      MOVW     R0,#+21930
     53              sys_info.ctrl.road    = DEFALUTROADID;
   \   00000076   0x2119             MOVS     R1,#+25
   \   00000078   0x80F9             STRH     R1,[R7, #+6]
   \   0000007A   0x8038             STRH     R0,[R7, #+0]
     54              sys_info.ctrl.ver     = SWVERSION;
   \   0000007C   0xF44F 0x7181      MOV      R1,#+258
   \   00000080   0x8139             STRH     R1,[R7, #+8]
   \   00000082   0x2058             MOVS     R0,#+88
     55              sys_info.ctrl.app     = app;                       // agv application, added 2013/12/14
     56              sys_info.ctrl.period  = DEFALUTPERIOD;             // report lamp information time(sec)  
   \   00000084   0x2101             MOVS     R1,#+1
   \   00000086   0x72B9             STRB     R1,[R7, #+10]
   \   00000088   0x8078             STRH     R0,[R7, #+2]
     57              sys_info.ctrl.config  = LAMP_CF_OPEN;              // default config with auto mode
   \   0000008A   0x2102             MOVS     R1,#+2
   \   0000008C   0x7339             STRB     R1,[R7, #+12]
   \   0000008E   0xF107 0x003A      ADD      R0,R7,#+58
     58              sys_info.ctrl.base    = MOBILEBASE;                // base number of vehicles
   \   00000092   0x21C8             MOVS     R1,#+200
   \   00000094   0x7379             STRB     R1,[R7, #+13]
   \   00000096   0x7045             STRB     R5,[R0, #+1]
     59              sys_info.ctrl.car     = MOBILEDEVS;
   \   00000098   0x2132             MOVS     R1,#+50
   \   0000009A   0x73B9             STRB     R1,[R7, #+14]
   \   0000009C   0x72FC             STRB     R4,[R7, #+11]
     60              sys_info.ctrl.call    = CALLERDEVS;
   \   0000009E   0x213C             MOVS     R1,#+60
   \   000000A0   0x73F9             STRB     R1,[R7, #+15]
     61              sys_info.ctrl.type    = 0x04;                      // 5,6,7,8 types
   \   000000A2   0x2104             MOVS     R1,#+4
   \   000000A4   0x7439             STRB     R1,[R7, #+16]
     62              sys_info.ctrl.release = 0x00;                      // debug version
   \   000000A6   0x2100             MOVS     R1,#+0
     63              if (app == eVehicle && type >= CARIDST && type < CARIDST + CARIDCNT)
   \   000000A8   0x2C02             CMP      R4,#+2
   \   000000AA   0x7479             STRB     R1,[R7, #+17]
   \   000000AC   0xD106             BNE.N    ??sea_writedefaultconfig_0
   \   000000AE   0xF1A5 0x0120      SUB      R1,R5,#+32
   \   000000B2   0x2920             CMP      R1,#+32
   \   000000B4   0xD202             BCS.N    ??sea_writedefaultconfig_0
     64                  sys_info.dev.num = sys_info.ctrl.base + DEFALUTLAMPNUM;            // 自己的物理编号，从手持设备中获得 
   \   000000B6   0x21CD             MOVS     R1,#+205
   \   000000B8   0x7001             STRB     R1,[R0, #+0]
   \   000000BA   0xE000             B.N      ??sea_writedefaultconfig_1
     65              else
     66                  sys_info.dev.num = DEFALUTLAMPNUM;            // 自己的物理编号，从手持设备中获得 
   \                     ??sea_writedefaultconfig_0: (+1)
   \   000000BC   0x7006             STRB     R6,[R0, #+0]
     67                
     68              while (retry --)
   \                     ??sea_writedefaultconfig_1: (+1)
   \   000000BE   0x4630             MOV      R0,R6
   \   000000C0   0x1E46             SUBS     R6,R0,#+1
   \   000000C2   0xB2C0             UXTB     R0,R0
   \   000000C4   0xB130             CBZ.N    R0,??sea_writedefaultconfig_2
     69              {
     70                  if (sea_flashwrite(0x00, (u16 *)&sys_info, sizeof(sys_info_t)) == EMBER_SUCCESS)
   \   000000C6   0x2258             MOVS     R2,#+88
   \   000000C8   0x4639             MOV      R1,R7
   \   000000CA   0x2000             MOVS     R0,#+0
   \   000000CC   0x.... 0x....      BL       sea_flashwrite
   \   000000D0   0x2800             CMP      R0,#+0
   \   000000D2   0xD1F4             BNE.N    ??sea_writedefaultconfig_1
     71                      break;;
     72              }
     73          }
   \                     ??sea_writedefaultconfig_2: (+1)
   \   000000D4   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return
     74          
     75          /////////////////////////////////////////////////////////////////////////////////////////////
     76          //
     77          //* 函数名      : void sea_updatechannel ( u8 num, u8 type, u8 index, u32 mask )
     78          //* 功能        : update channel information configuration
     79          //* 输入参数    : u8 num, u8 type, u8 index, u32 mask
     80          //* 输出参数    : 无
     81          //* 修改记录    : 无
     82          //* 备注        : 无
     83          //*------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
     84          void sea_updatechannel ( u8 num, u8 type, u8 index, u32 mask )
     85          {
   \                     sea_updatechannel: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
     86              u8  retry = 0x05; 
     87          
     88              sys_info.channel.index   = index;
   \   00000002   0x.... 0x....      LDR.W    R5,??DataTable19
   \   00000006   0xF105 0x0644      ADD      R6,R5,#+68
   \   0000000A   0x2405             MOVS     R4,#+5
     89              sys_info.channel.mask    = mask;                                         // 0x0000ffff, 0x10 channels
   \   0000000C   0x6033             STR      R3,[R6, #+0]
   \   0000000E   0x72B2             STRB     R2,[R6, #+10]
     90              sys_info.channel.panid   = panid_info[sys_info.channel.index].panid;     // DEF_PANID;
   \   00000010   0x7AB3             LDRB     R3,[R6, #+10]
   \   00000012   0x.... 0x....      ADR.W    R2,panid_info
   \   00000016   0xEB02 0x0383      ADD      R3,R2,R3, LSL #+2
   \   0000001A   0x885B             LDRH     R3,[R3, #+2]
   \   0000001C   0x80B3             STRH     R3,[R6, #+4]
     91              sys_info.channel.channel = panid_info[sys_info.channel.index].channel;   // DEF_CHANNEL;
   \   0000001E   0x7AB3             LDRB     R3,[R6, #+10]
   \   00000020   0xF812 0x2023      LDRB     R2,[R2, R3, LSL #+2]
   \   00000024   0x7272             STRB     R2,[R6, #+9]
     92              sys_info.dev.type        = type;
   \   00000026   0xF105 0x023A      ADD      R2,R5,#+58
   \   0000002A   0x7051             STRB     R1,[R2, #+1]
     93              sys_info.dev.num         = num;                                          // 自己的物理编号，从手持设备中获得 
   \   0000002C   0x7010             STRB     R0,[R2, #+0]
     94                
     95              while (retry --)
   \                     ??sea_updatechannel_0: (+1)
   \   0000002E   0x4620             MOV      R0,R4
   \   00000030   0x1E44             SUBS     R4,R0,#+1
   \   00000032   0xB2C0             UXTB     R0,R0
   \   00000034   0xB118             CBZ.N    R0,??sea_updatechannel_1
     96              {
     97                  if (sea_flashwrite(0x00, (u16 *)&sys_info, sizeof(sys_info_t)) == EMBER_SUCCESS)
   \   00000036   0x.... 0x....      BL       ?Subroutine1
     98                      break;;
     99              }
   \                     ??CrossCallReturnLabel_3: (+1)
   \   0000003A   0x2800             CMP      R0,#+0
   \   0000003C   0xD1F7             BNE.N    ??sea_updatechannel_0
    100          }
   \                     ??sea_updatechannel_1: (+1)
   \   0000003E   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \   00000000   0x2258             MOVS     R2,#+88
   \   00000002   0x4629             MOV      R1,R5
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x.... 0x....      B.W      sea_flashwrite
    101          
    102          /////////////////////////////////////////////////////////////////////////////////////////////
    103          //
    104          //* 函数名      : void sea_updatesysconfig ( void )
    105          //* 功能        : update system information configuration
    106          //* 输入参数    : 无
    107          //* 输出参数    : 无
    108          //* 修改记录    : 无
    109          //* 备注        : 无
    110          //*------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    111          void sea_updatesysconfig ( void )
    112          {
   \                     sea_updatesysconfig: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
    113              sys_info_t ptr;
    114              u8  retry = 0x05;
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable19_1
   \   00000006   0x6980             LDR      R0,[R0, #+24]
   \   00000008   0x2405             MOVS     R4,#+5
   \   0000000A   0xB097             SUB      SP,SP,#+92
   \   0000000C   0x0001             MOVS     R1,R0
   \   0000000E   0xBF18             IT       NE 
    115              
    116              if (table_info.clear)
    117                  table_info.clear();
   \   00000010   0x4780             BLXNE    R0
    118          
    119              sea_flashread(0x00, sizeof(sys_info_t), &ptr);
   \   00000012   0xAA00             ADD      R2,SP,#+0
   \   00000014   0x2158             MOVS     R1,#+88
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x.... 0x....      BL       sea_flashread
    120              if (sea_memcomp(&sys_info, &ptr, sizeof(sys_info_t)) != 0x00)
   \   0000001C   0x.... 0x....      LDR.W    R5,??DataTable19
   \   00000020   0x2258             MOVS     R2,#+88
   \   00000022   0xA900             ADD      R1,SP,#+0
   \   00000024   0x4628             MOV      R0,R5
   \   00000026   0x.... 0x....      BL       sea_memcomp
   \   0000002A   0xB138             CBZ.N    R0,??sea_updatesysconfig_0
    121              {
    122                  while (retry --)
   \                     ??sea_updatesysconfig_1: (+1)
   \   0000002C   0x4620             MOV      R0,R4
   \   0000002E   0x1E44             SUBS     R4,R0,#+1
   \   00000030   0xB2C0             UXTB     R0,R0
   \   00000032   0xB118             CBZ.N    R0,??sea_updatesysconfig_0
    123                  {
    124                      if (sea_flashwrite(0x00, (u16 *)&sys_info, sizeof(sys_info_t)) == EMBER_SUCCESS)
   \   00000034   0x.... 0x....      BL       ?Subroutine1
    125                          break;
    126                  }
    127              }
   \                     ??CrossCallReturnLabel_2: (+1)
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD1F7             BNE.N    ??sea_updatesysconfig_1
    128          }
   \                     ??sea_updatesysconfig_0: (+1)
   \   0000003C   0xB017             ADD      SP,SP,#+92
   \   0000003E   0xBD30             POP      {R4,R5,PC}       ;; return
    129          
    130          /////////////////////////////////////////////////////////////////////////////////////////////
    131          //
    132          //* 函数名      : void sea_adjustchannel ( u8 index )
    133          //* 功能        : change radio channel and panid
    134          //* 输入参数    : u8 index
    135          //* 输出参数    : 无
    136          //* 修改记录    : 无
    137          //* 备注        : 无
    138          //*------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    139          void sea_adjustchannel ( u8 index )
    140          {
   \                     sea_adjustchannel: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    141              if (sys_info.channel.index >= MAXCHANNEL)
   \   00000002   0x....             LDR.N    R1,??DataTable19_2
   \   00000004   0x7A8A             LDRB     R2,[R1, #+10]
   \   00000006   0x2A10             CMP      R2,#+16
   \   00000008   0xDA16             BGE.N    ??sea_adjustchannel_0
    142                  return;
    143              sys_info.channel.index   = index;
   \   0000000A   0x7288             STRB     R0,[R1, #+10]
    144              sys_info.channel.mask    = 0x01 << sys_info.channel.index;
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0xF991 0x200A      LDRSB    R2,[R1, #+10]
   \   00000012   0x4090             LSLS     R0,R0,R2
   \   00000014   0x6008             STR      R0,[R1, #+0]
    145              sys_info.channel.panid   = panid_info[sys_info.channel.index].panid;   
   \   00000016   0x7A8A             LDRB     R2,[R1, #+10]
   \   00000018   0x.... 0x....      ADR.W    R0,panid_info
   \   0000001C   0xEB00 0x0282      ADD      R2,R0,R2, LSL #+2
   \   00000020   0x8852             LDRH     R2,[R2, #+2]
   \   00000022   0x808A             STRH     R2,[R1, #+4]
    146              sys_info.channel.channel = panid_info[sys_info.channel.index].channel; 
   \   00000024   0x7A8A             LDRB     R2,[R1, #+10]
   \   00000026   0xF810 0x0022      LDRB     R0,[R0, R2, LSL #+2]
   \   0000002A   0x7248             STRB     R0,[R1, #+9]
    147              sea_updatesysconfig();
   \   0000002C   0x.... 0x....      BL       sea_updatesysconfig
    148             
    149              EZSP_Configuration();
   \   00000030   0xE8BD 0x4001      POP      {R0,LR}
   \   00000034   0x.... 0x....      B.W      EZSP_Configuration
   \                     ??sea_adjustchannel_0: (+1)
   \   00000038   0xBD01             POP      {R0,PC}          ;; return
    150          }
    151          
    152          /////////////////////////////////////////////////////////////////////////////////////////////
    153          //
    154          //* 函数名      : static void sea_writetotable ( u32 offset, void * data, u16 size )
    155          //* 功能        : write data flash
    156          //* 输入参数    : u32 offset, u16 * data, u16 size
    157          //* 输出参数    : EmberStatus status
    158          //* 修改记录    : 无
    159          //* 备注        : 无
    160          //*------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    161          static void sea_writetotable ( u32 addr, void * data, u16 size )
    162          {
   \                     sea_writetotable: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
    163              u8  retry = 0x05;
   \   00000008   0x2705             MOVS     R7,#+5
    164              
    165              while (retry --)
   \                     ??sea_writetotable_0: (+1)
   \   0000000A   0x4638             MOV      R0,R7
   \   0000000C   0x1E47             SUBS     R7,R0,#+1
   \   0000000E   0xB2C0             UXTB     R0,R0
   \   00000010   0xB130             CBZ.N    R0,??sea_writetotable_1
    166              {
    167                  if (sea_tableflashwrite(addr, data, size) == EMBER_SUCCESS)
   \   00000012   0x4632             MOV      R2,R6
   \   00000014   0x4629             MOV      R1,R5
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       sea_tableflashwrite
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD1F4             BNE.N    ??sea_writetotable_0
    168                      break;
    169              }
    170          }
   \                     ??sea_writetotable_1: (+1)
   \   00000020   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    171          
    172          /////////////////////////////////////////////////////////////////////////////////////////////
    173          //
    174          //* 函数名      : u8 sea_findchannelindex ( u8 channel, u16 pandid )
    175          //* 功能        : find index of radio channel and panid
    176          //* 输入参数    : u8 channel, u16 pandid 
    177          //* 输出参数    : index
    178          //* 修改记录    : 无
    179          //* 备注        : 无
    180          //*------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    181          u8 sea_findchannelindex ( u8 channel, u16 panid )
    182          {
   \                     sea_findchannelindex: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    183              for (u8 i = 0x00; i < MAXCHANNEL; i ++)
   \   00000002   0x2200             MOVS     R2,#+0
   \   00000004   0x.... 0x....      ADR.W    R3,panid_info
    184              {
    185                  if (panid == panid_info[i].panid && channel == panid_info[i].channel)
   \                     ??sea_findchannelindex_0: (+1)
   \   00000008   0xEB03 0x0482      ADD      R4,R3,R2, LSL #+2
   \   0000000C   0x8864             LDRH     R4,[R4, #+2]
   \   0000000E   0x42A1             CMP      R1,R4
   \   00000010   0xBF04             ITT      EQ 
   \   00000012   0xF813 0x4022      LDRBEQ   R4,[R3, R2, LSL #+2]
   \   00000016   0x42A0             CMPEQ    R0,R4
   \   00000018   0xD101             BNE.N    ??sea_findchannelindex_1
    186                      return i; 
   \   0000001A   0x4610             MOV      R0,R2
   \   0000001C   0xBD10             POP      {R4,PC}
    187              }
   \                     ??sea_findchannelindex_1: (+1)
   \   0000001E   0x1C52             ADDS     R2,R2,#+1
   \   00000020   0xB2D2             UXTB     R2,R2
   \   00000022   0x2A10             CMP      R2,#+16
   \   00000024   0xDBF0             BLT.N    ??sea_findchannelindex_0
    188              return 0xff;
   \   00000026   0x20FF             MOVS     R0,#+255
   \   00000028   0xBD10             POP      {R4,PC}          ;; return
    189          }
    190          
    191          /////////////////////////////////////////////////////////////////////////////////////////////
    192          //
    193          //* 函数名      : static void * sea_nextable ( u8 type )
    194          //* 功能        : get next device_t/passed_t in flash table
    195          //* 输入参数    : u8 type
    196          //* 输出参数    : pointer
    197          //* 修改记录    : 无
    198          //* 备注        : 无
    199          //*------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    200          static void * sea_nextable ( u8 type )
    201          {
    202              u16 addr = 0x00;
    203              
    204              table_info.index ++;
   \                     sea_nextable: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable19_1
   \   00000002   0xB510             PUSH     {R4,LR}
   \   00000004   0x880A             LDRH     R2,[R1, #+0]
    205              if (table_info.index >= table_info.size)
   \   00000006   0x888B             LDRH     R3,[R1, #+4]
   \   00000008   0x1C52             ADDS     R2,R2,#+1
   \   0000000A   0x800A             STRH     R2,[R1, #+0]
   \   0000000C   0x2400             MOVS     R4,#+0
   \   0000000E   0xB292             UXTH     R2,R2
   \   00000010   0x429A             CMP      R2,R3
   \   00000012   0xD301             BCC.N    ??sea_nextable_0
    206              {
    207                  table_info.index = table_info.size;
   \   00000014   0x800B             STRH     R3,[R1, #+0]
    208                  return NULL;
   \   00000016   0xE00E             B.N      ??sea_nextable_1
    209              }
    210              
    211              if (type == TBDEVICE)
   \                     ??sea_nextable_0: (+1)
   \   00000018   0x2801             CMP      R0,#+1
   \   0000001A   0xD103             BNE.N    ??sea_nextable_2
    212                  addr += sizeof(device_t) * table_info.index;
   \   0000001C   0x200A             MOVS     R0,#+10
   \   0000001E   0xFB00 0xF402      MUL      R4,R0,R2
   \   00000022   0xE002             B.N      ??sea_nextable_3
    213              else if (type == TBPASSED)
   \                     ??sea_nextable_2: (+1)
   \   00000024   0x2802             CMP      R0,#+2
   \   00000026   0xBF08             IT       EQ 
   \   00000028   0x0094             LSLEQ    R4,R2,#+2
    214                  addr += sizeof(passed_t) * table_info.index;
    215              
    216              if (sea_flashreadshort(TABLEOFFSET + addr) == ENDTABLE)
   \                     ??sea_nextable_3: (+1)
   \   0000002A   0x.... 0x....      BL       ?Subroutine3
   \                     ??CrossCallReturnLabel_8: (+1)
   \   0000002E   0xF64F 0x71FF      MOVW     R1,#+65535
   \   00000032   0x4288             CMP      R0,R1
   \   00000034   0xD101             BNE.N    ??sea_nextable_4
    217                  return NULL;
   \                     ??sea_nextable_1: (+1)
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0xBD10             POP      {R4,PC}
    218              return (void *)(STUSERADDR + TABLEOFFSET + addr);
   \                     ??sea_nextable_4: (+1)
   \   0000003A   0x.... 0x....      BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_4: (+1)
   \   0000003E   0xBD10             POP      {R4,PC}          ;; return
    219          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \   00000000   0xF504 0x5080      ADD      R0,R4,#+4096
   \   00000004   0xB280             UXTH     R0,R0
   \   00000006   0x.... 0x....      B.W      sea_flashreadshort

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \   00000000   0xB2A4             UXTH     R4,R4
   \                     ??Subroutine2_0: (+1)
   \   00000002   0xF104 0x6000      ADD      R0,R4,#+134217728
   \   00000006   0xF500 0x30E8      ADD      R0,R0,#+118784
   \   0000000A   0x4770             BX       LR
    220          
    221          /////////////////////////////////////////////////////////////////////////////////////////////
    222          //
    223          //* 函数名      : static void * sea_lastable ( u8 type )
    224          //* 功能        : get last device_t/passed_t in flash table
    225          //* 输入参数    : u8 type
    226          //* 输出参数    : pointer
    227          //* 修改记录    : 无
    228          //* 备注        : 无
    229          //*------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    230          static void * sea_lastable ( u8 type )
    231          {
   \                     sea_lastable: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    232              u16 addr = 0x00;
    233              
    234              if (table_info.index)
   \   00000002   0x....             LDR.N    R1,??DataTable19_1
   \   00000004   0x880A             LDRH     R2,[R1, #+0]
   \   00000006   0x2400             MOVS     R4,#+0
   \   00000008   0xB152             CBZ.N    R2,??sea_lastable_0
    235                  table_info.index --;
   \   0000000A   0xF64F 0x75FF      MOVW     R5,#+65535
   \   0000000E   0x18AA             ADDS     R2,R5,R2
    236              else 
    237                  return NULL;
    238              
    239              if (type == TBDEVICE)
   \   00000010   0x2801             CMP      R0,#+1
   \   00000012   0x800A             STRH     R2,[R1, #+0]
   \   00000014   0xD105             BNE.N    ??sea_lastable_1
    240                  addr += sizeof(device_t) * table_info.index;
   \   00000016   0xB292             UXTH     R2,R2
   \   00000018   0x200A             MOVS     R0,#+10
   \   0000001A   0xFB00 0xF402      MUL      R4,R0,R2
   \   0000001E   0xE004             B.N      ??sea_lastable_2
   \                     ??sea_lastable_0: (+1)
   \   00000020   0xE007             B.N      ??sea_lastable_3
    241              else if (type == TBPASSED)
   \                     ??sea_lastable_1: (+1)
   \   00000022   0x2802             CMP      R0,#+2
   \   00000024   0xBF04             ITT      EQ 
   \   00000026   0x0412             LSLEQ    R2,R2,#+16
   \   00000028   0x0B94             LSREQ    R4,R2,#+14
    242                  addr += sizeof(passed_t) * table_info.index;
    243              
    244              if (sea_flashreadshort(TABLEOFFSET + addr) == ENDTABLE)
   \                     ??sea_lastable_2: (+1)
   \   0000002A   0x.... 0x....      BL       ?Subroutine3
   \                     ??CrossCallReturnLabel_7: (+1)
   \   0000002E   0x42A8             CMP      R0,R5
   \   00000030   0xD101             BNE.N    ??sea_lastable_4
    245                  return NULL;
   \                     ??sea_lastable_3: (+1)
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0xBD32             POP      {R1,R4,R5,PC}
    246              return (void *)(STUSERADDR + TABLEOFFSET + addr);
   \                     ??sea_lastable_4: (+1)
   \   00000036   0x.... 0x....      BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_5: (+1)
   \   0000003A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    247          }
    248          
    249          /////////////////////////////////////////////////////////////////////////////////////////////
    250          //
    251          //* 函数名      : static void * sea_firstable ( void )
    252          //* 功能        : get first device_t/passed_t in flash table
    253          //* 输入参数    : 无
    254          //* 输出参数    : pointer
    255          //* 修改记录    : 无
    256          //* 备注        : 无
    257          //*------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    258          static void * sea_firstable ( void )
    259          {
   \                     sea_firstable: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    260              table_info.index = 0x00;
   \   00000002   0x....             LDR.N    R1,??DataTable19_1
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x8008             STRH     R0,[R1, #+0]
    261          
    262              if (sea_flashreadshort(TABLEOFFSET) == ENDTABLE)
   \   00000008   0xF44F 0x5080      MOV      R0,#+4096
   \   0000000C   0x.... 0x....      BL       sea_flashreadshort
   \   00000010   0xF64F 0x71FF      MOVW     R1,#+65535
   \   00000014   0x4288             CMP      R0,R1
   \   00000016   0xD101             BNE.N    ??sea_firstable_0
    263                  return NULL;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xBD02             POP      {R1,PC}
    264              return (void *)(STUSERADDR + TABLEOFFSET);
   \                     ??sea_firstable_0: (+1)
   \   0000001C   0x....             LDR.N    R0,??DataTable19_3  ;; 0x801d000
   \   0000001E   0xBD02             POP      {R1,PC}          ;; return
    265          }
    266          
    267          /////////////////////////////////////////////////////////////////////////////////////////////
    268          //
    269          //* 函数名      : static void * sea_firstable ( void )
    270          //* 功能        : get first device_t/passed_t in flash table
    271          //* 输入参数    : 无
    272          //* 输出参数    : EmberStatus
    273          //* 修改记录    : 无
    274          //* 备注        : 无
    275          //*------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    276          static EmberStatus sea_cleartable ( void )
    277          {
   \                     sea_cleartable: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    278              u16   addr;
    279              
    280              table_info.index = 0x00;
   \   00000002   0x....             LDR.N    R0,??DataTable19_1
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x6001             STR      R1,[R0, #+0]
    281              table_info.cnt   = 0x00;
    282              for (addr = 0x00; addr < TABLESIZE; addr += PAGESIZE)
   \   00000008   0x2400             MOVS     R4,#+0
    283              {
    284                  if (sea_tableflasherase(addr + STUSERADDR + TABLEOFFSET) != EMBER_SUCCESS)
   \                     ??sea_cleartable_0: (+1)
   \   0000000A   0x.... 0x....      BL       ??Subroutine2_0
   \                     ??CrossCallReturnLabel_6: (+1)
   \   0000000E   0x.... 0x....      BL       sea_tableflasherase
   \   00000012   0xB108             CBZ.N    R0,??sea_cleartable_1
    285                      return EMBER_ERR_FLASH_PROG_FAIL;
   \   00000014   0x204B             MOVS     R0,#+75
   \   00000016   0xBD10             POP      {R4,PC}
    286              }
   \                     ??sea_cleartable_1: (+1)
   \   00000018   0xF504 0x6480      ADD      R4,R4,#+1024
   \   0000001C   0xB2A4             UXTH     R4,R4
   \   0000001E   0xF5B4 0x5F80      CMP      R4,#+4096
   \   00000022   0xDBF2             BLT.N    ??sea_cleartable_0
   \   00000024   0xBD10             POP      {R4,PC}          ;; return
    287              return EMBER_SUCCESS;
    288          }
    289          
    290          /////////////////////////////////////////////////////////////////////////////////////////////
    291          //
    292          //* 函数名      : static u16 sea_getcount ( u8 type )
    293          //* 功能        : get count of device or passed in flash table
    294          //* 输入参数    : u8 type
    295          //* 输出参数    : count
    296          //* 修改记录    : 无
    297          //* 备注        : 无
    298          //*------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    299          static u16 sea_getcount ( u8 type )
    300          {
   \                     sea_getcount: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    301              u32  addr = (STUSERADDR + TABLEOFFSET);
    302              u16  cnt = 0x00;
   \   00000002   0x2100             MOVS     R1,#+0
    303              u8   size;
    304              
    305              size = (type == TBDEVICE) ? sizeof(device_t) : sizeof(passed_t);
   \   00000004   0x2801             CMP      R0,#+1
   \   00000006   0x....             LDR.N    R2,??DataTable19_3  ;; 0x801d000
   \   00000008   0xBF14             ITE      NE 
   \   0000000A   0x2004             MOVNE    R0,#+4
   \   0000000C   0x200A             MOVEQ    R0,#+10
    306              while (addr < STUSERADDR + TABLEOFFSET + TABLESIZE)
    307              {
    308                  if (*(u16 *)addr == ENDTABLE)
   \                     ??sea_getcount_0: (+1)
   \   0000000E   0x8813             LDRH     R3,[R2, #+0]
   \   00000010   0xF64F 0x74FF      MOVW     R4,#+65535
   \   00000014   0x42A3             CMP      R3,R4
   \   00000016   0xD004             BEQ.N    ??sea_getcount_1
    309                      return cnt;
    310                  cnt ++;
   \   00000018   0x1C49             ADDS     R1,R1,#+1
    311                  addr += size;
   \   0000001A   0x1882             ADDS     R2,R0,R2
    312              }
   \   0000001C   0x....             LDR.N    R3,??DataTable19_4  ;; 0x801e000
   \   0000001E   0x429A             CMP      R2,R3
   \   00000020   0xD3F5             BCC.N    ??sea_getcount_0
    313              return cnt;
   \                     ??sea_getcount_1: (+1)
   \   00000022   0xB288             UXTH     R0,R1
   \   00000024   0xBD10             POP      {R4,PC}          ;; return
    314          }
    315          
    316          /////////////////////////////////////////////////////////////////////////////////////////////
    317          //
    318          //* 函数名      : void  init_tableinfo ( void )
    319          //* 功能        : initialize table body
    320          //* 输入参数    : 无
    321          //* 输出参数    : 无
    322          //* 修改记录    : 无
    323          //* 备注        : 无
    324          //*------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    325          void  init_tableinfo ( void )
    326          {
   \                     init_tableinfo: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    327              sea_memset(&table_info, 0x00, sizeof(table_t));
   \   00000002   0x....             LDR.N    R4,??DataTable19_1
   \   00000004   0x221C             MOVS     R2,#+28
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x4620             MOV      R0,R4
   \   0000000A   0x.... 0x....      BL       sea_memset
    328              table_info.first = sea_firstable;
   \   0000000E   0x....             LDR.N    R0,??DataTable19_5
   \   00000010   0x60A0             STR      R0,[R4, #+8]
    329              table_info.next  = sea_nextable;
    330              table_info.last  = sea_lastable;
    331              table_info.clear = sea_cleartable;
    332              table_info.count = sea_getcount;
    333              
    334              table_info.index = 0x00;
   \   00000012   0xF44F 0x6180      MOV      R1,#+1024
   \   00000016   0x....             LDR.N    R0,??DataTable19_6
   \   00000018   0x60E0             STR      R0,[R4, #+12]
   \   0000001A   0x....             LDR.N    R0,??DataTable19_7
   \   0000001C   0x6120             STR      R0,[R4, #+16]
   \   0000001E   0x....             LDR.N    R0,??DataTable19_8
   \   00000020   0x61A0             STR      R0,[R4, #+24]
   \   00000022   0x....             LDR.N    R0,??DataTable19_9
   \   00000024   0x6160             STR      R0,[R4, #+20]
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x8020             STRH     R0,[R4, #+0]
   \   0000002A   0x....             LDR.N    R0,??DataTable19
   \   0000002C   0xF890 0x003B      LDRB     R0,[R0, #+59]
   \   00000030   0xB120             CBZ.N    R0,??init_tableinfo_0
   \   00000032   0x2810             CMP      R0,#+16
   \   00000034   0xDA02             BGE.N    ??init_tableinfo_0
    335          //    if (sys_info.dev.type == CENTERID)
    336              if (sys_info.dev.type >= CENTERIDST && sys_info.dev.type <= CENTERIDCNT)
    337              {
    338                  table_info.size  = TABLESIZE / sizeof(pdevice_t);
   \   00000036   0x80A1             STRH     R1,[R4, #+4]
    339                  table_info.cnt   = table_info.count(TBDEVICE);
   \   00000038   0x2001             MOVS     R0,#+1
   \   0000003A   0xE001             B.N      ??init_tableinfo_1
    340              }
    341              else
    342              {
    343                  table_info.size  = TABLESIZE / sizeof(passed_t);
   \                     ??init_tableinfo_0: (+1)
   \   0000003C   0x80A1             STRH     R1,[R4, #+4]
    344                  table_info.cnt   = table_info.count(TBPASSED);
   \   0000003E   0x2002             MOVS     R0,#+2
   \                     ??init_tableinfo_1: (+1)
   \   00000040   0x6961             LDR      R1,[R4, #+20]
   \   00000042   0x4788             BLX      R1
   \   00000044   0x8060             STRH     R0,[R4, #+2]
    345              }
    346          }
   \   00000046   0xBD10             POP      {R4,PC}          ;; return
    347          
    348          /////////////////////////////////////////////////////////////////////////////////////////////
    349          //
    350          //* 函数名      : u8 sea_isdeviceintable ( pdevice_t ptr )
    351          //* 功能        : find device in flash table
    352          //* 输入参数    : pdevice_t ptr
    353          //* 输出参数    : true/flase
    354          //* 修改记录    : 无
    355          //* 备注        : 无
    356          //*------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    357          u8 sea_isdeviceintable ( pdevice_t ptr )
    358          {
   \                     sea_isdeviceintable: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x.... 0x....      BL       ?Subroutine0
    359              pdevice_t  tmp = (pdevice_t)(STUSERADDR + TABLEOFFSET);
    360          
    361              for (u16 i = 0x00; i < table_info.size; i ++, tmp ++)
   \                     ??CrossCallReturnLabel_0: (+1)
   \   00000006   0xE001             B.N      ??sea_isdeviceintable_0
   \                     ??sea_isdeviceintable_1: (+1)
   \   00000008   0x1C76             ADDS     R6,R6,#+1
   \   0000000A   0x350A             ADDS     R5,R5,#+10
   \                     ??sea_isdeviceintable_0: (+1)
   \   0000000C   0x88B8             LDRH     R0,[R7, #+4]
   \   0000000E   0xB2B6             UXTH     R6,R6
   \   00000010   0x4286             CMP      R6,R0
   \   00000012   0xD208             BCS.N    ??sea_isdeviceintable_2
    362              {
    363                  if (sea_memcomp(tmp, ptr, sizeof(device_t)) == 0x00)
   \   00000014   0x220A             MOVS     R2,#+10
   \   00000016   0x4621             MOV      R1,R4
   \   00000018   0x4628             MOV      R0,R5
   \   0000001A   0x.... 0x....      BL       sea_memcomp
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD1F2             BNE.N    ??sea_isdeviceintable_1
    364                      return 0x01;
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0xBDF2             POP      {R1,R4-R7,PC}
    365              }
    366              return 0x00;
   \                     ??sea_isdeviceintable_2: (+1)
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    367          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x4604             MOV      R4,R0
   \   00000002   0x....             LDR.N    R5,??DataTable19_3  ;; 0x801d000
   \   00000004   0x....             LDR.N    R7,??DataTable19_1
   \   00000006   0x2600             MOVS     R6,#+0
   \   00000008   0x4770             BX       LR
    368          
    369          /////////////////////////////////////////////////////////////////////////////////////////////
    370          //
    371          //* 函数名      : pdevice_t sea_findphydevice ( EmberEUI64 * eui )
    372          //* 功能        : find the device_t in flash table
    373          //* 输入参数    : EmberEUI64 * eui
    374          //* 输出参数    : pointer of device_t
    375          //* 修改记录    : 无
    376          //* 备注        : 无
    377          //*------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    378          pdevice_t sea_findphydevice ( EmberEUI64 * eui, pdevice_t ptr )
    379          {
   \                     sea_findphydevice: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x4688             MOV      R8,R1
    380              pdevice_t  tmp = (pdevice_t)(STUSERADDR + TABLEOFFSET);
   \   00000008   0x....             LDR.N    R6,??DataTable19_3  ;; 0x801d000
    381          
    382              for (u16 i = 0x00; i < table_info.size; i ++, tmp ++)
   \   0000000A   0x....             LDR.N    R5,??DataTable19_1
   \   0000000C   0x2700             MOVS     R7,#+0
   \   0000000E   0xE001             B.N      ??sea_findphydevice_0
   \                     ??sea_findphydevice_1: (+1)
   \   00000010   0x1C7F             ADDS     R7,R7,#+1
   \   00000012   0x360A             ADDS     R6,R6,#+10
   \                     ??sea_findphydevice_0: (+1)
   \   00000014   0x88A8             LDRH     R0,[R5, #+4]
   \   00000016   0xB2BF             UXTH     R7,R7
   \   00000018   0x4287             CMP      R7,R0
   \   0000001A   0xD20D             BCS.N    ??sea_findphydevice_2
    383              {
    384                  if (sea_memcomp(tmp->eui, eui, EUI64_SIZE) == 0x00)
   \   0000001C   0x2208             MOVS     R2,#+8
   \   0000001E   0x4621             MOV      R1,R4
   \   00000020   0x4630             MOV      R0,R6
   \   00000022   0x.... 0x....      BL       sea_memcomp
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD1F2             BNE.N    ??sea_findphydevice_1
    385                  {
    386                      sea_memcpy(ptr, tmp, sizeof(device_t));
   \   0000002A   0x220A             MOVS     R2,#+10
   \   0000002C   0x4631             MOV      R1,R6
   \   0000002E   0x4640             MOV      R0,R8
   \   00000030   0x.... 0x....      BL       sea_memcpy
    387                      return ptr;
   \   00000034   0x4640             MOV      R0,R8
   \   00000036   0xE000             B.N      ??sea_findphydevice_3
    388                  }
    389              }
    390              return NULL;
   \                     ??sea_findphydevice_2: (+1)
   \   00000038   0x2000             MOVS     R0,#+0
   \                     ??sea_findphydevice_3: (+1)
   \   0000003A   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    391          }
    392          
    393          /////////////////////////////////////////////////////////////////////////////////////////////
    394          //
    395          //* 函数名      : pdevice_t sea_findnumdevice ( u16 num, pdevice_t ptr )
    396          //* 功能        : find the device_t in flash table
    397          //* 输入参数    : u16 num, pdevice_t ptr
    398          //* 输出参数    : pointer of device_t
    399          //* 修改记录    : 无
    400          //* 备注        : 无
    401          //*------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    402          pdevice_t sea_findnumdevice ( u16 num, pdevice_t ptr )
    403          {
   \                     sea_findnumdevice: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x460C             MOV      R4,R1
    404              pdevice_t  tmp = (pdevice_t)(STUSERADDR + TABLEOFFSET);
   \   00000004   0x....             LDR.N    R1,??DataTable19_3  ;; 0x801d000
    405          
    406              for (u16 i = 0x00; i < table_info.size; i ++, tmp ++)
   \   00000006   0x....             LDR.N    R3,??DataTable19_1
   \   00000008   0x2200             MOVS     R2,#+0
   \   0000000A   0xE001             B.N      ??sea_findnumdevice_0
   \                     ??sea_findnumdevice_1: (+1)
   \   0000000C   0x1C52             ADDS     R2,R2,#+1
   \   0000000E   0x310A             ADDS     R1,R1,#+10
   \                     ??sea_findnumdevice_0: (+1)
   \   00000010   0x889D             LDRH     R5,[R3, #+4]
   \   00000012   0xB292             UXTH     R2,R2
   \   00000014   0x42AA             CMP      R2,R5
   \   00000016   0xD208             BCS.N    ??sea_findnumdevice_2
    407              {
    408                  if (tmp->num == num)
   \   00000018   0x7A0D             LDRB     R5,[R1, #+8]
   \   0000001A   0x4285             CMP      R5,R0
   \   0000001C   0xD1F6             BNE.N    ??sea_findnumdevice_1
    409                  {
    410                      sea_memcpy(ptr, tmp, sizeof(device_t));
   \   0000001E   0x220A             MOVS     R2,#+10
   \   00000020   0x4620             MOV      R0,R4
   \   00000022   0x.... 0x....      BL       sea_memcpy
    411                      return ptr;
   \   00000026   0x4620             MOV      R0,R4
   \   00000028   0xBD32             POP      {R1,R4,R5,PC}
    412                  }
    413              }
    414              return NULL;
   \                     ??sea_findnumdevice_2: (+1)
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    415          }
    416          
    417          /////////////////////////////////////////////////////////////////////////////////////////////
    418          //
    419          //* 函数名      : void sea_savedevice ( pdevice_t ptr )
    420          //* 功能        : save new device_t to flash table
    421          //* 输入参数    : pdevice_t ptr
    422          //* 输出参数    : 无
    423          //* 修改记录    : 无
    424          //* 备注        : 无
    425          //*------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    426          void sea_savedevice ( pdevice_t ptr )
    427          {
   \                     sea_savedevice: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    428              pdevice_t  tmp = (pdevice_t)(STUSERADDR + TABLEOFFSET);
    429          
    430              tmp += table_info.cnt;
    431              sea_writetotable((u32)tmp, ptr, sizeof(device_t));
   \   00000002   0x....             LDR.N    R4,??DataTable19_1
   \   00000004   0x8863             LDRH     R3,[R4, #+2]
   \   00000006   0x4601             MOV      R1,R0
   \   00000008   0x220A             MOVS     R2,#+10
   \   0000000A   0x....             LDR.N    R0,??DataTable19_3  ;; 0x801d000
   \   0000000C   0xFB02 0x0003      MLA      R0,R2,R3,R0
   \   00000010   0x.... 0x....      BL       sea_writetotable
    432              table_info.cnt ++;
   \   00000014   0x.... 0x....      BL       ?Subroutine4
    433              if (table_info.cnt >= table_info.size)
   \                     ??CrossCallReturnLabel_9: (+1)
   \   00000018   0xBF24             ITT      CS 
   \   0000001A   0x2000             MOVCS    R0,#+0
   \   0000001C   0x8060             STRHCS   R0,[R4, #+2]
    434                  table_info.cnt = 0x00;
    435          }
   \   0000001E   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4: (+1)
   \   00000000   0x8860             LDRH     R0,[R4, #+2]
   \   00000002   0x88A1             LDRH     R1,[R4, #+4]
   \   00000004   0x1C40             ADDS     R0,R0,#+1
   \   00000006   0x8060             STRH     R0,[R4, #+2]
   \   00000008   0xB280             UXTH     R0,R0
   \   0000000A   0x4288             CMP      R0,R1
   \   0000000C   0x4770             BX       LR
    436          
    437          /////////////////////////////////////////////////////////////////////////////////////////////
    438          //
    439          //* 函数名      : u8 sea_ispassedintable ( ppassed_t ptr )
    440          //* 功能        : is passed_t in flash table
    441          //* 输入参数    : ppassed_t ptr
    442          //* 输出参数    : true/flash
    443          //* 修改记录    : 无
    444          //* 备注        : 无
    445          //*------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    446          u8 sea_ispassedintable ( ppassed_t ptr )
    447          {
   \                     sea_ispassedintable: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x.... 0x....      BL       ?Subroutine0
    448              ppassed_t  tmp = (ppassed_t)(STUSERADDR + TABLEOFFSET);
    449              
    450              for (u16 i = 0x00; i < table_info.size; i ++, tmp ++)
   \                     ??CrossCallReturnLabel_1: (+1)
   \   00000006   0xE000             B.N      ??sea_ispassedintable_0
   \                     ??sea_ispassedintable_1: (+1)
   \   00000008   0x1C76             ADDS     R6,R6,#+1
   \                     ??sea_ispassedintable_0: (+1)
   \   0000000A   0x88B8             LDRH     R0,[R7, #+4]
   \   0000000C   0xB2B6             UXTH     R6,R6
   \   0000000E   0x4286             CMP      R6,R0
   \   00000010   0xD20D             BCS.N    ??sea_ispassedintable_2
    451              {
    452                  if (sea_memcomp(tmp, ptr, sizeof(passed_t)) == 0x00)
   \   00000012   0x2204             MOVS     R2,#+4
   \   00000014   0x4621             MOV      R1,R4
   \   00000016   0x4628             MOV      R0,R5
   \   00000018   0x.... 0x....      BL       sea_memcomp
   \   0000001C   0xB908             CBNZ.N   R0,??sea_ispassedintable_3
    453                      return 0x01;
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0xBDF2             POP      {R1,R4-R7,PC}
    454                  if (*(u16 *)tmp == ENDTABLE)
   \                     ??sea_ispassedintable_3: (+1)
   \   00000022   0xF835 0x0B04      LDRH     R0,[R5], #+4
   \   00000026   0xF64F 0x71FF      MOVW     R1,#+65535
   \   0000002A   0x4288             CMP      R0,R1
   \   0000002C   0xD1EC             BNE.N    ??sea_ispassedintable_1
    455                      break;
    456              }
    457              return 0x00;
   \                     ??sea_ispassedintable_2: (+1)
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    458          }
    459          
    460          /////////////////////////////////////////////////////////////////////////////////////////////
    461          //
    462          //* 函数名      : ppassed_t sea_finpassed ( u8 card )
    463          //* 功能        : find the last passed_t in flash table
    464          //* 输入参数    : u8 card
    465          //* 输出参数    : pointer of passed_t
    466          //* 修改记录    : 无
    467          //* 备注        : 无
    468          //*------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    469          ppassed_t sea_finpassed ( u8 card )
    470          {
   \                     sea_finpassed: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    471              ppassed_t  tmp = (ppassed_t)(STUSERADDR + TABLEOFFSET);
   \   00000002   0x....             LDR.N    R2,??DataTable19_3  ;; 0x801d000
    472              ppassed_t  qtr = NULL;
    473              
    474              for (u16 i = 0x00; i < table_info.size; i ++, tmp ++)
   \   00000004   0x....             LDR.N    R4,??DataTable19_1
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x2300             MOVS     R3,#+0
   \   0000000A   0xF64F 0x76FF      MOVW     R6,#+65535
   \   0000000E   0xE000             B.N      ??sea_finpassed_0
   \                     ??sea_finpassed_1: (+1)
   \   00000010   0x1C5B             ADDS     R3,R3,#+1
   \                     ??sea_finpassed_0: (+1)
   \   00000012   0x88A5             LDRH     R5,[R4, #+4]
   \   00000014   0xB29B             UXTH     R3,R3
   \   00000016   0x42AB             CMP      R3,R5
   \   00000018   0xD207             BCS.N    ??sea_finpassed_2
    475              {
    476                  if (tmp->act.id == card)
   \   0000001A   0x7895             LDRB     R5,[R2, #+2]
   \   0000001C   0x4285             CMP      R5,R0
   \   0000001E   0xBF08             IT       EQ 
   \   00000020   0x4611             MOVEQ    R1,R2
    477                      qtr = tmp;
    478                  if (*(u16 *)tmp == ENDTABLE)
   \   00000022   0xF832 0x5B04      LDRH     R5,[R2], #+4
   \   00000026   0x42B5             CMP      R5,R6
   \   00000028   0xD1F2             BNE.N    ??sea_finpassed_1
    479                      break;
    480              }
    481              return qtr;
   \                     ??sea_finpassed_2: (+1)
   \   0000002A   0x4608             MOV      R0,R1
   \   0000002C   0xBD70             POP      {R4-R6,PC}       ;; return
    482          }
    483          
    484          /////////////////////////////////////////////////////////////////////////////////////////////
    485          //
    486          //* 函数名      : void sea_writedefaultconfig ( void )
    487          //* 功能        : write default system information configuration
    488          //* 输入参数    : 无
    489          //* 输出参数    : 无
    490          //* 修改记录    : 无
    491          //* 备注        : 无
    492          //*------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    493          void sea_savepassed ( ppassed_t ptr )
    494          {
   \                     sea_savepassed: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    495              ppassed_t  tmp = (ppassed_t)(STUSERADDR + TABLEOFFSET);
    496          
    497              tmp += table_info.cnt;
    498              sea_writetotable((u32)tmp, ptr, sizeof(passed_t));
   \   00000002   0x....             LDR.N    R4,??DataTable19_1
   \   00000004   0x4601             MOV      R1,R0
   \   00000006   0x8860             LDRH     R0,[R4, #+2]
   \   00000008   0x0080             LSLS     R0,R0,#+2
   \   0000000A   0xF100 0x6000      ADD      R0,R0,#+134217728
   \   0000000E   0x2204             MOVS     R2,#+4
   \   00000010   0xF500 0x30E8      ADD      R0,R0,#+118784
   \   00000014   0x.... 0x....      BL       sea_writetotable
    499              table_info.cnt ++;
   \   00000018   0x.... 0x....      BL       ?Subroutine4
    500              if (table_info.cnt >= table_info.size)
   \                     ??CrossCallReturnLabel_10: (+1)
   \   0000001C   0xBF24             ITT      CS 
   \   0000001E   0x2000             MOVCS    R0,#+0
   \   00000020   0x8060             STRHCS   R0,[R4, #+2]
    501                  table_info.cnt = 0x00;
    502          }
   \   00000022   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19:
   \   00000000   0x........         DC32     sys_info

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_1:
   \   00000000   0x........         DC32     table_info

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_2:
   \   00000000   0x........         DC32     sys_info+0x44

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_3:
   \   00000000   0x0801D000         DC32     0x801d000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_4:
   \   00000000   0x0801E000         DC32     0x801e000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_5:
   \   00000000   0x........         DC32     sea_firstable

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_6:
   \   00000000   0x........         DC32     sea_nextable

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_7:
   \   00000000   0x........         DC32     sea_lastable

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_8:
   \   00000000   0x........         DC32     sea_cleartable

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_9:
   \   00000000   0x........         DC32     sea_getcount

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x53 0x65          DC8 53H, 65H, 61H, 72H, 65H, 6EH, 20H, 4EH
   \              0x61 0x72    
   \              0x65 0x6E    
   \              0x20 0x4E    
   \   00000008   0x65 0x74          DC8 65H, 74H, 77H, 6FH, 72H, 6BH, 0, 0
   \              0x77 0x6F    
   \              0x72 0x6B    
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_1:
   \   00000000   0x4D 0x69          DC8 4DH, 69H, 72H, 63H, 6FH, 20H, 53H, 65H
   \              0x72 0x63    
   \              0x6F 0x20    
   \              0x53 0x65    
   \   00000008   0x72 0x76          DC8 72H, 76H, 6FH, 0, 0
   \              0x6F 0x00    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ?_2:
   \   00000000   0x73 0x65          DC8 73H, 65H, 61H, 72H, 65H, 6EH, 0, 0
   \              0x61 0x72    
   \              0x65 0x6E    
   \              0x00 0x00    
    503          
    504          //////////////////////////////////////////////////////////////////////////////////////

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   init_tableinfo
         8   -- Indirect call
         8   -> sea_memset
       8   sea_adjustchannel
         8   -> sea_updatesysconfig
       8   sea_cleartable
         8   -> sea_tableflasherase
       8   sea_findchannelindex
      16   sea_findnumdevice
        16   -> sea_memcpy
      24   sea_findphydevice
        24   -> sea_memcomp
        24   -> sea_memcpy
      16   sea_finpassed
       8   sea_firstable
         8   -> sea_flashreadshort
       8   sea_getcount
      24   sea_isdeviceintable
        24   -> sea_memcomp
      24   sea_ispassedintable
        24   -> sea_memcomp
      16   sea_lastable
        16   -> sea_flashreadshort
       8   sea_nextable
         8   -> sea_flashreadshort
       8   sea_savedevice
         8   -> sea_writetotable
       8   sea_savepassed
         8   -> sea_writetotable
      16   sea_updatechannel
        16   -> sea_flashwrite
     104   sea_updatesysconfig
       104   -- Indirect call
       104   -> sea_flashread
       104   -> sea_flashwrite
       104   -> sea_memcomp
      32   sea_writedefaultconfig
        32   -> sea_flashwrite
        32   -> sea_memcpy
        32   -> sea_memset
      24   sea_writetotable
        24   -> sea_tableflashwrite


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable19
       4  ??DataTable19_1
       4  ??DataTable19_2
       4  ??DataTable19_3
       4  ??DataTable19_4
       4  ??DataTable19_5
       4  ??DataTable19_6
       4  ??DataTable19_7
       4  ??DataTable19_8
       4  ??DataTable19_9
      10  ?Subroutine0
      10  ?Subroutine1
      12  ?Subroutine2
      10  ?Subroutine3
      14  ?Subroutine4
      16  ?_0
      16  ?_1
       8  ?_2
      72  init_tableinfo
      80  panid_info
      58  sea_adjustchannel
      38  sea_cleartable
      42  sea_findchannelindex
      46  sea_findnumdevice
      62  sea_findphydevice
      46  sea_finpassed
      32  sea_firstable
      38  sea_getcount
      42  sea_isdeviceintable
      50  sea_ispassedintable
      60  sea_lastable
      64  sea_nextable
      32  sea_savedevice
      36  sea_savepassed
      64  sea_updatechannel
      64  sea_updatesysconfig
     216  sea_writedefaultconfig
      34  sea_writetotable
      28  table_info

 
    28 bytes in section .bss
 1 312 bytes in section .text
 
 1 312 bytes of CODE memory
    28 bytes of DATA memory

Errors: none
Warnings: none
